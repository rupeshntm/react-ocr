{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/rupeshchavan/Desktop/react-ocr/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/rupeshchavan/Desktop/react-ocr/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/Users/rupeshchavan/Desktop/react-ocr/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _this = this;\n\nvar createJob = require('./createJob');\n\nvar _require = require('./utils/log'),\n    log = _require.log;\n\nvar getId = require('./utils/getId');\n\nvar schedulerCounter = 0;\n\nmodule.exports = function () {\n  var id = getId('Scheduler', schedulerCounter);\n  var workers = {};\n  var runningWorkers = {};\n  var jobQueue = [];\n  schedulerCounter += 1;\n\n  var getQueueLen = function getQueueLen() {\n    return jobQueue.length;\n  };\n\n  var getNumWorkers = function getNumWorkers() {\n    return Object.keys(workers).length;\n  };\n\n  var dequeue = function dequeue() {\n    if (jobQueue.length !== 0) {\n      var wIds = Object.keys(workers);\n\n      for (var i = 0; i < wIds.length; i += 1) {\n        if (typeof runningWorkers[wIds[i]] === 'undefined') {\n          jobQueue[0](workers[wIds[i]]);\n          break;\n        }\n      }\n    }\n  };\n\n  var queue = function queue(action, payload) {\n    return new Promise(function (resolve, reject) {\n      var job = createJob({\n        action: action,\n        payload: payload\n      });\n      jobQueue.push( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(w) {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  jobQueue.shift();\n                  runningWorkers[w.id] = job;\n                  _context.prev = 2;\n                  _context.t0 = resolve;\n                  _context.next = 6;\n                  return w[action].apply(_this, [].concat(_toConsumableArray(payload), [job.id]));\n\n                case 6:\n                  _context.t1 = _context.sent;\n                  (0, _context.t0)(_context.t1);\n                  _context.next = 13;\n                  break;\n\n                case 10:\n                  _context.prev = 10;\n                  _context.t2 = _context[\"catch\"](2);\n                  reject(_context.t2);\n\n                case 13:\n                  _context.prev = 13;\n                  delete runningWorkers[w.id];\n                  dequeue();\n                  return _context.finish(13);\n\n                case 17:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 10, 13, 17]]);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      log(\"[\".concat(id, \"]: Add \").concat(job.id, \" to JobQueue\"));\n      log(\"[\".concat(id, \"]: JobQueue length=\").concat(jobQueue.length));\n      dequeue();\n    });\n  };\n\n  var addWorker = function addWorker(w) {\n    workers[w.id] = w;\n    log(\"[\".concat(id, \"]: Add \").concat(w.id));\n    log(\"[\".concat(id, \"]: Number of workers=\").concat(getNumWorkers()));\n    dequeue();\n    return w.id;\n  };\n\n  var addJob = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(action) {\n      var _len,\n          payload,\n          _key,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(getNumWorkers() === 0)) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw Error(\"[\".concat(id, \"]: You need to have at least one worker before adding jobs\"));\n\n            case 2:\n              for (_len = _args2.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                payload[_key - 1] = _args2[_key];\n              }\n\n              return _context2.abrupt(\"return\", queue(action, payload));\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function addJob(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var terminate = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              Object.keys(workers).forEach( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(wid) {\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _context3.next = 2;\n                          return workers[wid].terminate();\n\n                        case 2:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }));\n\n                return function (_x3) {\n                  return _ref4.apply(this, arguments);\n                };\n              }());\n              jobQueue = [];\n\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function terminate() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    addWorker: addWorker,\n    addJob: addJob,\n    terminate: terminate,\n    getQueueLen: getQueueLen,\n    getNumWorkers: getNumWorkers\n  };\n};","map":{"version":3,"sources":["/Users/rupeshchavan/Desktop/react-ocr/node_modules/tesseract.js/src/createScheduler.js"],"names":["createJob","require","log","getId","schedulerCounter","module","exports","id","workers","runningWorkers","jobQueue","getQueueLen","length","getNumWorkers","Object","keys","dequeue","wIds","i","queue","action","payload","Promise","resolve","reject","job","push","w","shift","apply","addWorker","addJob","Error","terminate","forEach","wid"],"mappings":"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","sourcesContent":["const createJob = require('./createJob');\nconst { log } = require('./utils/log');\nconst getId = require('./utils/getId');\n\nlet schedulerCounter = 0;\n\nmodule.exports = () => {\n  const id = getId('Scheduler', schedulerCounter);\n  const workers = {};\n  const runningWorkers = {};\n  let jobQueue = [];\n\n  schedulerCounter += 1;\n\n  const getQueueLen = () => jobQueue.length;\n  const getNumWorkers = () => Object.keys(workers).length;\n\n  const dequeue = () => {\n    if (jobQueue.length !== 0) {\n      const wIds = Object.keys(workers);\n      for (let i = 0; i < wIds.length; i += 1) {\n        if (typeof runningWorkers[wIds[i]] === 'undefined') {\n          jobQueue[0](workers[wIds[i]]);\n          break;\n        }\n      }\n    }\n  };\n\n  const queue = (action, payload) => (\n    new Promise((resolve, reject) => {\n      const job = createJob({ action, payload });\n      jobQueue.push(async (w) => {\n        jobQueue.shift();\n        runningWorkers[w.id] = job;\n        try {\n          resolve(await w[action].apply(this, [...payload, job.id]));\n        } catch (err) {\n          reject(err);\n        } finally {\n          delete runningWorkers[w.id];\n          dequeue();\n        }\n      });\n      log(`[${id}]: Add ${job.id} to JobQueue`);\n      log(`[${id}]: JobQueue length=${jobQueue.length}`);\n      dequeue();\n    })\n  );\n\n  const addWorker = (w) => {\n    workers[w.id] = w;\n    log(`[${id}]: Add ${w.id}`);\n    log(`[${id}]: Number of workers=${getNumWorkers()}`);\n    dequeue();\n    return w.id;\n  };\n\n  const addJob = async (action, ...payload) => {\n    if (getNumWorkers() === 0) {\n      throw Error(`[${id}]: You need to have at least one worker before adding jobs`);\n    }\n    return queue(action, payload);\n  };\n\n  const terminate = async () => {\n    Object.keys(workers).forEach(async (wid) => {\n      await workers[wid].terminate();\n    });\n    jobQueue = [];\n  };\n\n  return {\n    addWorker,\n    addJob,\n    terminate,\n    getQueueLen,\n    getNumWorkers,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}